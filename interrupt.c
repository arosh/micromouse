#include <avr/io.h>

/*
 *	Name		: Init_Timer1
 *	Sumarry		: タイマー1のレジスタ設定
 *	Description	: CTCモードで約10msの周期で TIMER1_COMPA_VECT を発生させる
 */
void Init_Timer1(void)
{
	//TCCR1A(Timer Counter1 Control Register A)
	//	7,6: OC1Aから出力するPWM波の設定
	//		COM1A1=0, COM1A0=0で標準ポート動作 (データシート p.83, 表16-2)
	//		#7 = 0, #6 = 0
	//
	//	5,4: OC1Bから出力するPWM波の設定
	//		COM1B1=0, COM1B0=0で標準ポート動作 (データシート p.83, 表16-2)
	//		#5 = 0, #4 = 0
	//
	//	3,2: リザーブビット
	//		#3 = 0, #2 = 0
	//
	//	1,0: PWM波形の種類の設定(下記のTCCR1Bにも設定が跨っているので注意)
	//		WGM13=0, WGM12=1, WGM11=0, WGM10=0で通常動作(データシート p.84, 表16-5の番号4)
	//		#1 = 0, #0 = 0
	TCCR1A = 0b00000000;

	//TCCR1B(Timer Counter1 Control register B)
	//	7,6: ICNC1, ICES1 捕獲機道入力という謎の機能 (データシート p.82)
	//		今回は使用しない
	//		#7 = 0, #6 = 0
	//
	//	5: リザーブビット
	//		#5 = 0
	//
	//	4,3: PWM波形の種類の設定(上記に述べた設定の残り)
	//		#4 = 0, #3 = 1
	//
	//	2,1,0: 分周器設定
	//		ATmega1284P-AUの動作クロックは20MHz(ヒューズビットで分周設定を解除後)
	//		分周は1/64
	//		20MHz/64 ==> 約312.5kHz(3.2us)
	//		#2 = 0, #1 = 1, #0 = 1
	//		
	TCCR1B = 0b00001011;

	//TCNT1(Timer Counter1)
	//		タイマカウンタ(16bit)に直接アクセスできる
	//		初期値をいれる
	//
	TCNT1 = 0;

	//OCR1A(Timer Counter1 Output Compare A Register)
	//      いつコンペアマッチAをさせるかを設定する(16bit)
	//
	//		100ms間隔で割り込みを発生させ速度制御を行う
	//		タイマの動作クロックはメインクロックを64分周しているので321.5kHz(3.2us)
	//		10msを作りたいので
	//		(10 * 10^-3) / (3.2 * 10^-6) = 3125
	//
	//
	OCR1A = 3125;

	//OCR1B(Timer Counter1 Output Compare B Register)
	//		いつコンペアマッチBをさせるかを設定する(16bit)
	//		今回は使用しない。
	OCR1B = 0;

	//TIMSK1(Timer Counter 1 Interrupt Mask Register)
	//		タイマ割り込みを許可するためのレジスタ
	//	7,6,5,4,3: リザーブビット
	//		#7-3 = 0
	//
	//  2 : B比較の許可
	//		使用しないので
	//		#2 = 0
	//
	//  1 : A比較の許可
	//		使用するので
	//		#1 = 1
	//
	//	0 : 漏れ割り込み許可
	//		使用しないので
	//		#0 = 0
	TIMSK1 = 0b00000010;
}

/*
 *	Name		: Init_Timer3
 *	Sumarry		: タイマー3のレジスタ設定
 *	Description	: CTCモードで102.4usの周期で TIMER3_COMPA_VECT を発生させる
 */
void Init_Timer3(void)
{
	//TCCR3A(Timer Counter3 Control Register A)
	//	7,6: OC3Aから出力するPWM波の設定
	//		COM3A1=0, COM3A0=0で標準ポート動作 (データシート p.83, 表16-2)
	//		#7 = 0, #6 = 0
	//
	//	5,4: OC3Bから出力するPWM波の設定
	//		COM3B1=0, COM3B0=0で標準ポート動作 (データシート p.83, 表16-2)
	//		#5 = 0, #4 = 0
	//
	//	3,2: リザーブビット
	//		#3 = 0, #2 = 0
	//
	//	1,0: PWM波形の種類の設定(下記のTCCR3Bにも設定が跨っているので注意)
	//		WGM33=0, WGM32=1, WGM31=0, WGM30=0 CTCモード(データシート p.84, 表16-5の番号4)
	//		#1 = 0, #0 = 0
	TCCR3A = 0b00000000;

	//TCCR3B(Timer Counter3 Control register B)
	//	7,6: ICNC3, ICES3 捕獲起動入力という謎の機能 (データシート p.82)
	//		今回は使用しない
	//		#7 = 0, #6 = 0
	//
	//	5: リザーブビット
	//		#4 = 0
	//
	//	4,3: PWM波形の種類の設定(上記に述べた設定の残り)
	//		#4 = 0, #3 = 1
	//
	//	2,1,0: 分周器設定 (データシートp.85, 表16-6)
	//		ATmega1284P-AUの動作クロックは20MHz(ヒューズビットで分周設定を解除後)
	//		メインクロックを64分周して使用する
	//		20MHz(0.05us)/ 64 = 312.5kHz(3.2us)
	//		#2 = 0, #1 = 1, #0 = 1
	TCCR3B = 0b00001011;

	//TCNT3(Timer Counter3)
	//		タイマカウンタ(16bit)に直接アクセスできる
	//		初期値をいれる
	TCNT3 = 0;

	//OCR3A(Timer Counter3 Output Compare A Register)
	//		いつコンペアマッチAをさせるかを設定する(16bit)
	//
	//		コンペアマッチAではロータリーエンコーダカウントと姿勢制御の割り込みを行う
	//		ロータリーエンコーダの回転を読むので、カウントレートがサンプリング周波数よりも、
	//		大きくなってはいけないので今回のサンプリング周波数は10kHz(100us)とする
	//		1クロックが312.5KHz(3.2us)なので
	//		100u / 3.2u = 31.25 今回は31にする
	//
	//		また同時に距離センサの割り込みを行う
	//		データシートのAD変換のところを見ると、
	//		変換時間は13-260us(50k-1MHz)と書いてある。
	//		今回AD変換の動作クロックは156kHzなので線形に推移すると仮定すると約240usになる。
	//
	//		AD変換時間は約240us またマルチプレクサの切り替え時間に50usいれている。
	//		一回のADCにかかる時間は250usになる。
	//
	//		AD変換が完了する前に割り込んでも意味がないので、割り込み間隔は250us以上にする必要がある。
	//		だいたい40Hz(0.025s)位(1個当たり1秒間に10サンプリング)すればいいと思うので
	//		コンペアマッチAの割り込み関数の中で250カウントする
	//		サンプリング周期は100usなので
	//		0.025 / (100 * 10^-6) = 250 より割り込み関数内で250カウントとることにする
	OCR3A = 31;

	//OCR3B(Timer Counter3 Output Compare B Register)
	//		いつコンペアマッチBをさせるかを設定する(16bit)
	//		だいたい40Hz(0.025s)位(1個当たり1秒間に10サンプリング)すればいいと思うので
	//		0.025s / (3.2 * 10^-6) = 7812.5なので、今回は7812とする。
	OCR3B = 0;

	//TIMSK3(Timer Counter 3 Interrupt Mask Register)
	//		タイマ割り込みを許可するためのレジスタ
	//
	//	7-3: リザーブビット
	//		 #7-3 = 0
	//
	//  2  : B比較の許可
	//		 使用しないので
	//		 #2 = 0
	//
	//  1 : A比較の許可
	//		使用するので
	//		#1 = 1
	//
	//	0 : 漏れ割り込み許可
	//		使用しないので
	//		#0 = 0
	TIMSK3 = 0b00000010;
}
// vim: noet ts=4 sw=4 sts=0
